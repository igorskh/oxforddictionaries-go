/*
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 2.5.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package oxforddictionaries

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UtilityApiService UtilityApi service
type UtilityApiService service

type ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLangDomains string
	targetLangDomains string
	appId *string
	appKey *string
}

func (r ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest) AppId(appId string) ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest {
	r.appId = &appId
	return r
}
func (r ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest) AppKey(appKey string) ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.DomainsSourceLangDomainsTargetLangDomainsGetExecute(r)
}

/*
 * DomainsSourceLangDomainsTargetLangDomainsGet Lists available domains in a bilingual dataset
 * Returns a list of the available [domains](documentation/glossary?term=domain) for a given bilingual language dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLangDomains Language code of the source language in a bilingual dataset.
 * @param targetLangDomains Language code of the target language in a bilingual dataset.
 * @return ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest
 */
func (a *UtilityApiService) DomainsSourceLangDomainsTargetLangDomainsGet(ctx _context.Context, sourceLangDomains string, targetLangDomains string) ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest {
	return ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLangDomains: sourceLangDomains,
		targetLangDomains: targetLangDomains,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) DomainsSourceLangDomainsTargetLangDomainsGetExecute(r ApiDomainsSourceLangDomainsTargetLangDomainsGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.DomainsSourceLangDomainsTargetLangDomainsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{source_lang_domains}/{target_lang_domains}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang_domains"+"}", _neturl.PathEscape(parameterToString(r.sourceLangDomains, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_lang_domains"+"}", _neturl.PathEscape(parameterToString(r.targetLangDomains, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDomainsSourceLangGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLang string
	appId *string
	appKey *string
}

func (r ApiDomainsSourceLangGetRequest) AppId(appId string) ApiDomainsSourceLangGetRequest {
	r.appId = &appId
	return r
}
func (r ApiDomainsSourceLangGetRequest) AppKey(appKey string) ApiDomainsSourceLangGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiDomainsSourceLangGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.DomainsSourceLangGetExecute(r)
}

/*
 * DomainsSourceLangGet Lists available domains in a monolingual dataset
 * Returns a list of the available [domains](documentation/glossary?term=domain) for a given monolingual language dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLang Language code of the source language in a monolingual dataset.
 * @return ApiDomainsSourceLangGetRequest
 */
func (a *UtilityApiService) DomainsSourceLangGet(ctx _context.Context, sourceLang string) ApiDomainsSourceLangGetRequest {
	return ApiDomainsSourceLangGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLang: sourceLang,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) DomainsSourceLangGetExecute(r ApiDomainsSourceLangGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.DomainsSourceLangGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domains/{source_lang}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang"+"}", _neturl.PathEscape(parameterToString(r.sourceLang, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldsEndpointGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	endpoint string
	appId *string
	appKey *string
}

func (r ApiFieldsEndpointGetRequest) AppId(appId string) ApiFieldsEndpointGetRequest {
	r.appId = &appId
	return r
}
func (r ApiFieldsEndpointGetRequest) AppKey(appKey string) ApiFieldsEndpointGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiFieldsEndpointGetRequest) Execute() (Filters, *_nethttp.Response, error) {
	return r.ApiService.FieldsEndpointGetExecute(r)
}

/*
 * FieldsEndpointGet Lists available fields for specific endpoint
 * Returns the lists of fields available to construct API requests for a given endpoint.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param endpoint Name of the endpoint
 * @return ApiFieldsEndpointGetRequest
 */
func (a *UtilityApiService) FieldsEndpointGet(ctx _context.Context, endpoint string) ApiFieldsEndpointGetRequest {
	return ApiFieldsEndpointGetRequest{
		ApiService: a,
		ctx: ctx,
		endpoint: endpoint,
	}
}

/*
 * Execute executes the request
 * @return Filters
 */
func (a *UtilityApiService) FieldsEndpointGetExecute(r ApiFieldsEndpointGetRequest) (Filters, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Filters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.FieldsEndpointGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fields/{endpoint}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint"+"}", _neturl.PathEscape(parameterToString(r.endpoint, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldsGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	appId *string
	appKey *string
}

func (r ApiFieldsGetRequest) AppId(appId string) ApiFieldsGetRequest {
	r.appId = &appId
	return r
}
func (r ApiFieldsGetRequest) AppKey(appKey string) ApiFieldsGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiFieldsGetRequest) Execute() (Filters, *_nethttp.Response, error) {
	return r.ApiService.FieldsGetExecute(r)
}

/*
 * FieldsGet Lists available fields
 * Returns a list of the available fields to construct API requests.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiFieldsGetRequest
 */
func (a *UtilityApiService) FieldsGet(ctx _context.Context) ApiFieldsGetRequest {
	return ApiFieldsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Filters
 */
func (a *UtilityApiService) FieldsGetExecute(r ApiFieldsGetRequest) (Filters, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Filters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.FieldsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFiltersEndpointGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	endpoint string
	appId *string
	appKey *string
}

func (r ApiFiltersEndpointGetRequest) AppId(appId string) ApiFiltersEndpointGetRequest {
	r.appId = &appId
	return r
}
func (r ApiFiltersEndpointGetRequest) AppKey(appKey string) ApiFiltersEndpointGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiFiltersEndpointGetRequest) Execute() (Filters, *_nethttp.Response, error) {
	return r.ApiService.FiltersEndpointGetExecute(r)
}

/*
 * FiltersEndpointGet Lists available filters for specific endpoint
 * Returns a list of all the valid filters by endpoint to construct API requests.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param endpoint Name of the endpoint.
 * @return ApiFiltersEndpointGetRequest
 */
func (a *UtilityApiService) FiltersEndpointGet(ctx _context.Context, endpoint string) ApiFiltersEndpointGetRequest {
	return ApiFiltersEndpointGetRequest{
		ApiService: a,
		ctx: ctx,
		endpoint: endpoint,
	}
}

/*
 * Execute executes the request
 * @return Filters
 */
func (a *UtilityApiService) FiltersEndpointGetExecute(r ApiFiltersEndpointGetRequest) (Filters, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Filters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.FiltersEndpointGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filters/{endpoint}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint"+"}", _neturl.PathEscape(parameterToString(r.endpoint, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFiltersGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	appId *string
	appKey *string
}

func (r ApiFiltersGetRequest) AppId(appId string) ApiFiltersGetRequest {
	r.appId = &appId
	return r
}
func (r ApiFiltersGetRequest) AppKey(appKey string) ApiFiltersGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiFiltersGetRequest) Execute() (Filters, *_nethttp.Response, error) {
	return r.ApiService.FiltersGetExecute(r)
}

/*
 * FiltersGet Lists available filters
 * Returns a list of all the valid filters to construct API requests.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiFiltersGetRequest
 */
func (a *UtilityApiService) FiltersGet(ctx _context.Context) ApiFiltersGetRequest {
	return ApiFiltersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Filters
 */
func (a *UtilityApiService) FiltersGetExecute(r ApiFiltersGetRequest) (Filters, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Filters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.FiltersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGrammaticalFeaturesSourceLangGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLang string
	appId *string
	appKey *string
}

func (r ApiGrammaticalFeaturesSourceLangGetRequest) AppId(appId string) ApiGrammaticalFeaturesSourceLangGetRequest {
	r.appId = &appId
	return r
}
func (r ApiGrammaticalFeaturesSourceLangGetRequest) AppKey(appKey string) ApiGrammaticalFeaturesSourceLangGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiGrammaticalFeaturesSourceLangGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.GrammaticalFeaturesSourceLangGetExecute(r)
}

/*
 * GrammaticalFeaturesSourceLangGet Lists available grammatical features in a monolingual dataset
 * Returns a list of the available [grammatical features](documentation/glossary?term=grammaticalfeatures) for a given monolingual dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLang Language code of the source language in a monolingual dataset.
 * @return ApiGrammaticalFeaturesSourceLangGetRequest
 */
func (a *UtilityApiService) GrammaticalFeaturesSourceLangGet(ctx _context.Context, sourceLang string) ApiGrammaticalFeaturesSourceLangGetRequest {
	return ApiGrammaticalFeaturesSourceLangGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLang: sourceLang,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) GrammaticalFeaturesSourceLangGetExecute(r ApiGrammaticalFeaturesSourceLangGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.GrammaticalFeaturesSourceLangGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/grammaticalFeatures/{source_lang}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang"+"}", _neturl.PathEscape(parameterToString(r.sourceLang, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLangGrammatical string
	targetLangGrammatical string
	appId *string
	appKey *string
}

func (r ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest) AppId(appId string) ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest {
	r.appId = &appId
	return r
}
func (r ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest) AppKey(appKey string) ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.GrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetExecute(r)
}

/*
 * GrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGet Lists available grammatical features in a bilingual dataset
 * Returns a list of the available [grammatical features](documentation/glossary?term=grammaticalfeatures) for a given bilingual dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLangGrammatical Language code of the source language in a bilingual dataset.
 * @param targetLangGrammatical Language code of the target language in a bilingual dataset.
 * @return ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest
 */
func (a *UtilityApiService) GrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGet(ctx _context.Context, sourceLangGrammatical string, targetLangGrammatical string) ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest {
	return ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLangGrammatical: sourceLangGrammatical,
		targetLangGrammatical: targetLangGrammatical,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) GrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetExecute(r ApiGrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.GrammaticalFeaturesSourceLangGrammaticalTargetLangGrammaticalGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/grammaticalFeatures/{source_lang_grammatical}/{target_lang_grammatical}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang_grammatical"+"}", _neturl.PathEscape(parameterToString(r.sourceLangGrammatical, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_lang_grammatical"+"}", _neturl.PathEscape(parameterToString(r.targetLangGrammatical, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLanguagesGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	appId *string
	appKey *string
	sourceLanguage *string
	targetLanguage *string
}

func (r ApiLanguagesGetRequest) AppId(appId string) ApiLanguagesGetRequest {
	r.appId = &appId
	return r
}
func (r ApiLanguagesGetRequest) AppKey(appKey string) ApiLanguagesGetRequest {
	r.appKey = &appKey
	return r
}
func (r ApiLanguagesGetRequest) SourceLanguage(sourceLanguage string) ApiLanguagesGetRequest {
	r.sourceLanguage = &sourceLanguage
	return r
}
func (r ApiLanguagesGetRequest) TargetLanguage(targetLanguage string) ApiLanguagesGetRequest {
	r.targetLanguage = &targetLanguage
	return r
}

func (r ApiLanguagesGetRequest) Execute() (Languages, *_nethttp.Response, error) {
	return r.ApiService.LanguagesGetExecute(r)
}

/*
 * LanguagesGet Returns the names of Dictionaries in the API
 * Returns the names of monolingual and bilingual language datasets available in the API

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiLanguagesGetRequest
 */
func (a *UtilityApiService) LanguagesGet(ctx _context.Context) ApiLanguagesGetRequest {
	return ApiLanguagesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Languages
 */
func (a *UtilityApiService) LanguagesGetExecute(r ApiLanguagesGetRequest) (Languages, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Languages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.LanguagesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.sourceLanguage != nil {
		localVarQueryParams.Add("sourceLanguage", parameterToString(*r.sourceLanguage, ""))
	}
	if r.targetLanguage != nil {
		localVarQueryParams.Add("targetLanguage", parameterToString(*r.targetLanguage, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLexicalCategoriesSourceLangGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLang string
	appId *string
	appKey *string
}

func (r ApiLexicalCategoriesSourceLangGetRequest) AppId(appId string) ApiLexicalCategoriesSourceLangGetRequest {
	r.appId = &appId
	return r
}
func (r ApiLexicalCategoriesSourceLangGetRequest) AppKey(appKey string) ApiLexicalCategoriesSourceLangGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiLexicalCategoriesSourceLangGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.LexicalCategoriesSourceLangGetExecute(r)
}

/*
 * LexicalCategoriesSourceLangGet Lists available lexical categories in a monolingual dataset
 * Returns a list of available [lexical categories](documentation/glossary?term=lexicalcategory) for a given language dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLang Language code of the source language in a monolingual dataset.
 * @return ApiLexicalCategoriesSourceLangGetRequest
 */
func (a *UtilityApiService) LexicalCategoriesSourceLangGet(ctx _context.Context, sourceLang string) ApiLexicalCategoriesSourceLangGetRequest {
	return ApiLexicalCategoriesSourceLangGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLang: sourceLang,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) LexicalCategoriesSourceLangGetExecute(r ApiLexicalCategoriesSourceLangGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.LexicalCategoriesSourceLangGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lexicalCategories/{source_lang}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang"+"}", _neturl.PathEscape(parameterToString(r.sourceLang, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLangLexical string
	targetLangLexical string
	appId *string
	appKey *string
}

func (r ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest) AppId(appId string) ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest {
	r.appId = &appId
	return r
}
func (r ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest) AppKey(appKey string) ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.LexicalCategoriesSourceLangLexicalTargetLangLexicalGetExecute(r)
}

/*
 * LexicalCategoriesSourceLangLexicalTargetLangLexicalGet Lists available lexical categories in a bilingual dataset
 * Returns a list of available [lexical categories](documentation/glossary?term=lexicalcategory) for a given bilingual dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLangLexical Language code of the source language in a bilingual dataset.
 * @param targetLangLexical Language code of the target language in a bilingual dataset.
 * @return ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest
 */
func (a *UtilityApiService) LexicalCategoriesSourceLangLexicalTargetLangLexicalGet(ctx _context.Context, sourceLangLexical string, targetLangLexical string) ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest {
	return ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLangLexical: sourceLangLexical,
		targetLangLexical: targetLangLexical,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) LexicalCategoriesSourceLangLexicalTargetLangLexicalGetExecute(r ApiLexicalCategoriesSourceLangLexicalTargetLangLexicalGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.LexicalCategoriesSourceLangLexicalTargetLangLexicalGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lexicalCategories/{source_lang_lexical}/{target_lang_lexical}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang_lexical"+"}", _neturl.PathEscape(parameterToString(r.sourceLangLexical, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_lang_lexical"+"}", _neturl.PathEscape(parameterToString(r.targetLangLexical, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistersSourceLangGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLang string
	appId *string
	appKey *string
}

func (r ApiRegistersSourceLangGetRequest) AppId(appId string) ApiRegistersSourceLangGetRequest {
	r.appId = &appId
	return r
}
func (r ApiRegistersSourceLangGetRequest) AppKey(appKey string) ApiRegistersSourceLangGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiRegistersSourceLangGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.RegistersSourceLangGetExecute(r)
}

/*
 * RegistersSourceLangGet Lists available registers in a  monolingual dataset
 * Returns a list of the available [registers](documentation/glossary?term=registers) for a given monolingual language dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLang Language code of the source language in a monolingual dataset.
 * @return ApiRegistersSourceLangGetRequest
 */
func (a *UtilityApiService) RegistersSourceLangGet(ctx _context.Context, sourceLang string) ApiRegistersSourceLangGetRequest {
	return ApiRegistersSourceLangGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLang: sourceLang,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) RegistersSourceLangGetExecute(r ApiRegistersSourceLangGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.RegistersSourceLangGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registers/{source_lang}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang"+"}", _neturl.PathEscape(parameterToString(r.sourceLang, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest struct {
	ctx _context.Context
	ApiService *UtilityApiService
	sourceLangRegisters string
	targetLangRegisters string
	appId *string
	appKey *string
}

func (r ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest) AppId(appId string) ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest {
	r.appId = &appId
	return r
}
func (r ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest) AppKey(appKey string) ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest {
	r.appKey = &appKey
	return r
}

func (r ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest) Execute() (UtilityLabels, *_nethttp.Response, error) {
	return r.ApiService.RegistersSourceLangRegistersTargetLangRegistersGetExecute(r)
}

/*
 * RegistersSourceLangRegistersTargetLangRegistersGet Lists available registers in a bilingual dataset
 * Returns a list of the available [registers](documentation/glossary?term=registers) for a given bilingual language dataset.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLangRegisters Language code of the source language in a bilingual dataset.
 * @param targetLangRegisters Language code of the target language in a bilingual dataset.
 * @return ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest
 */
func (a *UtilityApiService) RegistersSourceLangRegistersTargetLangRegistersGet(ctx _context.Context, sourceLangRegisters string, targetLangRegisters string) ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest {
	return ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLangRegisters: sourceLangRegisters,
		targetLangRegisters: targetLangRegisters,
	}
}

/*
 * Execute executes the request
 * @return UtilityLabels
 */
func (a *UtilityApiService) RegistersSourceLangRegistersTargetLangRegistersGetExecute(r ApiRegistersSourceLangRegistersTargetLangRegistersGetRequest) (UtilityLabels, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UtilityLabels
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UtilityApiService.RegistersSourceLangRegistersTargetLangRegistersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/registers/{source_lang_registers}/{target_lang_registers}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang_registers"+"}", _neturl.PathEscape(parameterToString(r.sourceLangRegisters, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_lang_registers"+"}", _neturl.PathEscape(parameterToString(r.targetLangRegisters, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
