/*
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 2.5.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package oxforddictionaries

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// WordsApiService WordsApi service
type WordsApiService service

type ApiWordsSourceLangGetRequest struct {
	ctx _context.Context
	ApiService *WordsApiService
	sourceLang string
	q *string
	appId *string
	appKey *string
	fields *[]string
	grammaticalFeatures *string
	lexicalCategory *string
	domains *string
	registers *string
}

func (r ApiWordsSourceLangGetRequest) Q(q string) ApiWordsSourceLangGetRequest {
	r.q = &q
	return r
}
func (r ApiWordsSourceLangGetRequest) AppId(appId string) ApiWordsSourceLangGetRequest {
	r.appId = &appId
	return r
}
func (r ApiWordsSourceLangGetRequest) AppKey(appKey string) ApiWordsSourceLangGetRequest {
	r.appKey = &appKey
	return r
}
func (r ApiWordsSourceLangGetRequest) Fields(fields []string) ApiWordsSourceLangGetRequest {
	r.fields = &fields
	return r
}
func (r ApiWordsSourceLangGetRequest) GrammaticalFeatures(grammaticalFeatures string) ApiWordsSourceLangGetRequest {
	r.grammaticalFeatures = &grammaticalFeatures
	return r
}
func (r ApiWordsSourceLangGetRequest) LexicalCategory(lexicalCategory string) ApiWordsSourceLangGetRequest {
	r.lexicalCategory = &lexicalCategory
	return r
}
func (r ApiWordsSourceLangGetRequest) Domains(domains string) ApiWordsSourceLangGetRequest {
	r.domains = &domains
	return r
}
func (r ApiWordsSourceLangGetRequest) Registers(registers string) ApiWordsSourceLangGetRequest {
	r.registers = &registers
	return r
}

func (r ApiWordsSourceLangGetRequest) Execute() (RetrieveEntry, *_nethttp.Response, error) {
	return r.ApiService.WordsSourceLangGetExecute(r)
}

/*
 * WordsSourceLangGet Check if an inflected form exists in the dictionary and retrieve the entries data of its root form.
 * 
Use this endpoint to retrieve definitions, examples and other information for a given dictionary word or an inflection (e.g., running > run). The response contains information about the lemmas to which the given word/inflected form is linked.

The results can be filtered by lexicalCategories, domains, registers or grammaticalFeatures. Filters can be combined.

In addition, users can use fields to project some of the properties.

Combining different filters will build a query using 'AND' operators, while if a filter contains more than one value it will build a query using 'OR' operators. For example, a combination of filters like '?grammaticalFeatures=singular&lexicalCategory=noun,verb' will return entries which match the query ('noun' OR 'verb') AND 'singular'.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sourceLang Language code of the source language in a monolingual dataset.
 * @return ApiWordsSourceLangGetRequest
 */
func (a *WordsApiService) WordsSourceLangGet(ctx _context.Context, sourceLang string) ApiWordsSourceLangGetRequest {
	return ApiWordsSourceLangGetRequest{
		ApiService: a,
		ctx: ctx,
		sourceLang: sourceLang,
	}
}

/*
 * Execute executes the request
 * @return RetrieveEntry
 */
func (a *WordsApiService) WordsSourceLangGetExecute(r ApiWordsSourceLangGetRequest) (RetrieveEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RetrieveEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WordsApiService.WordsSourceLangGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/words/{source_lang}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_lang"+"}", _neturl.PathEscape(parameterToString(r.sourceLang, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}
	if r.appId == nil {
		return localVarReturnValue, nil, reportError("appId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, "csv"))
	}
	if r.grammaticalFeatures != nil {
		localVarQueryParams.Add("grammaticalFeatures", parameterToString(*r.grammaticalFeatures, ""))
	}
	if r.lexicalCategory != nil {
		localVarQueryParams.Add("lexicalCategory", parameterToString(*r.lexicalCategory, ""))
	}
	if r.domains != nil {
		localVarQueryParams.Add("domains", parameterToString(*r.domains, ""))
	}
	if r.registers != nil {
		localVarQueryParams.Add("registers", parameterToString(*r.registers, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["app_id"] = parameterToString(*r.appId, "")
	localVarHeaderParams["app_key"] = parameterToString(*r.appKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 414 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
